#!/usr/bin/env python3
"""
{{ node_name }} - Generated by RobotStudio (Lifecycle Node)

{{ description }}

Lifecycle States:
- UNCONFIGURED: Initial state after construction
- INACTIVE: Configured but not yet active (resources allocated)
- ACTIVE: Fully operational (publishing/subscribing)
- FINALIZED: Shutdown complete

Generated on: {{ generation_date }}
"""

import rclpy
from rclpy.lifecycle import Node as LifecycleNode
from rclpy.lifecycle import State, TransitionCallbackReturn
{% for msg_import in message_imports %}
{{ msg_import }}
{% endfor %}


class {{ class_name }}(LifecycleNode):
    """{{ description }}"""

    def __init__(self):
        super().__init__('{{ node_name }}')

        self.get_logger().info('{{ node_name }} lifecycle node constructed (UNCONFIGURED state)')
{% if parameters %}

        # Declare parameters
{% for param in parameters %}
        self.declare_parameter('{{ param.name }}', {{ param.default_value }})
{% endfor %}
{% endif %}

        # Initialize member variables (allocated in on_configure)
{% if publishers %}
{% for pub in publishers %}
        self.{{ pub.var_name }} = None
{% endfor %}
{% endif %}
{% if subscribers %}
{% for sub in subscribers %}
        self.{{ sub.var_name }} = None
{% endfor %}
{% endif %}
{% if timers %}
{% for timer in timers %}
        self.{{ timer.var_name }} = None
{% endfor %}
{% endif %}

    def on_configure(self, state: State) -> TransitionCallbackReturn:
        """
        Callback for configure transition (UNCONFIGURED -> INACTIVE)

        Allocate resources: create publishers, subscribers, timers
        Do NOT start publishing/processing yet

        Returns:
            SUCCESS if configuration successful, FAILURE otherwise
        """
        self.get_logger().info('on_configure() called - allocating resources')

        try:
{% if publishers %}
            # Create publishers (inactive)
{% for pub in publishers %}
            self.{{ pub.var_name }} = self.create_lifecycle_publisher(
                {{ pub.msg_class }},
                '{{ pub.topic }}',
                {{ pub.queue_size }}
            )
            self.get_logger().info('Created publisher for {{ pub.topic }}')
{% endfor %}
{% endif %}
{% if subscribers %}
            # Create subscribers
{% for sub in subscribers %}
            self.{{ sub.var_name }} = self.create_subscription(
                {{ sub.msg_class }},
                '{{ sub.topic }}',
                self.{{ sub.callback_name }},
                {{ sub.queue_size }}
            )
            self.get_logger().info('Created subscriber for {{ sub.topic }}')
{% endfor %}
{% endif %}
{% if timers %}
            # Create timers (inactive)
{% for timer in timers %}
            self.{{ timer.var_name }} = self.create_timer(
                {{ timer.period }},
                self.{{ timer.callback_name }}
            )
            self.{{ timer.var_name }}.cancel()  # Start inactive
            self.get_logger().info('Created timer with period {{ timer.period }}s (inactive)')
{% endfor %}
{% endif %}

            self.get_logger().info('Configuration complete - transitioning to INACTIVE state')
            return TransitionCallbackReturn.SUCCESS

        except Exception as e:
            self.get_logger().error(f'Configuration failed: {e}')
            return TransitionCallbackReturn.FAILURE

    def on_activate(self, state: State) -> TransitionCallbackReturn:
        """
        Callback for activate transition (INACTIVE -> ACTIVE)

        Start operations: activate publishers, start timers
        Begin normal operation

        Returns:
            SUCCESS if activation successful, FAILURE otherwise
        """
        self.get_logger().info('on_activate() called - starting operations')

        try:
{% if publishers %}
            # Activate publishers
{% for pub in publishers %}
            self.{{ pub.var_name }}.on_activate(state)
            self.get_logger().info('Activated publisher for {{ pub.topic }}')
{% endfor %}
{% endif %}
{% if timers %}
            # Start timers
{% for timer in timers %}
            self.{{ timer.var_name }}.reset()
            self.get_logger().info('Started timer')
{% endfor %}
{% endif %}

            self.get_logger().info('Activation complete - now in ACTIVE state')
            return TransitionCallbackReturn.SUCCESS

        except Exception as e:
            self.get_logger().error(f'Activation failed: {e}')
            return TransitionCallbackReturn.FAILURE

    def on_deactivate(self, state: State) -> TransitionCallbackReturn:
        """
        Callback for deactivate transition (ACTIVE -> INACTIVE)

        Stop operations: deactivate publishers, stop timers
        Keep resources allocated for quick restart

        Returns:
            SUCCESS if deactivation successful, FAILURE otherwise
        """
        self.get_logger().info('on_deactivate() called - stopping operations')

        try:
{% if publishers %}
            # Deactivate publishers
{% for pub in publishers %}
            self.{{ pub.var_name }}.on_deactivate(state)
            self.get_logger().info('Deactivated publisher for {{ pub.topic }}')
{% endfor %}
{% endif %}
{% if timers %}
            # Stop timers
{% for timer in timers %}
            self.{{ timer.var_name }}.cancel()
            self.get_logger().info('Stopped timer')
{% endfor %}
{% endif %}

            self.get_logger().info('Deactivation complete - now in INACTIVE state')
            return TransitionCallbackReturn.SUCCESS

        except Exception as e:
            self.get_logger().error(f'Deactivation failed: {e}')
            return TransitionCallbackReturn.FAILURE

    def on_cleanup(self, state: State) -> TransitionCallbackReturn:
        """
        Callback for cleanup transition (INACTIVE -> UNCONFIGURED)

        Release resources: destroy publishers, subscribers, timers
        Return to clean slate

        Returns:
            SUCCESS if cleanup successful, FAILURE otherwise
        """
        self.get_logger().info('on_cleanup() called - releasing resources')

        try:
{% if publishers %}
            # Destroy publishers
{% for pub in publishers %}
            self.destroy_publisher(self.{{ pub.var_name }})
            self.{{ pub.var_name }} = None
{% endfor %}
{% endif %}
{% if subscribers %}
            # Destroy subscribers
{% for sub in subscribers %}
            self.destroy_subscription(self.{{ sub.var_name }})
            self.{{ sub.var_name }} = None
{% endfor %}
{% endif %}
{% if timers %}
            # Destroy timers
{% for timer in timers %}
            self.destroy_timer(self.{{ timer.var_name }})
            self.{{ timer.var_name }} = None
{% endfor %}
{% endif %}

            self.get_logger().info('Cleanup complete - now in UNCONFIGURED state')
            return TransitionCallbackReturn.SUCCESS

        except Exception as e:
            self.get_logger().error(f'Cleanup failed: {e}')
            return TransitionCallbackReturn.FAILURE

    def on_shutdown(self, state: State) -> TransitionCallbackReturn:
        """
        Callback for shutdown transition (ANY -> FINALIZED)

        Emergency shutdown from any state

        Returns:
            SUCCESS if shutdown successful, FAILURE otherwise
        """
        self.get_logger().info('on_shutdown() called - emergency shutdown')

        try:
            # Clean up any active resources
{% if timers %}
{% for timer in timers %}
            if self.{{ timer.var_name }}:
                self.{{ timer.var_name }}.cancel()
{% endfor %}
{% endif %}

            self.get_logger().info('Shutdown complete - now in FINALIZED state')
            return TransitionCallbackReturn.SUCCESS

        except Exception as e:
            self.get_logger().error(f'Shutdown failed: {e}')
            return TransitionCallbackReturn.FAILURE

{% if timers %}
{% for timer in timers %}
    def {{ timer.callback_name }}(self):
        """Timer callback - executes every {{ timer.period }} seconds (only when ACTIVE)"""
        # Only publish when in ACTIVE state (state 3)
        # States: 1=unconfigured, 2=inactive, 3=active, 4=finalized
        if self._state_machine.current_state[1] != 'active':
            return

{% if timer.code %}
{{ timer.code | indent(8, True) }}
{% else %}
        # TODO: Implement timer logic
        self.get_logger().info('Timer callback triggered')
{% endif %}

{% endfor %}
{% endif %}
{% if subscribers %}
{% for sub in subscribers %}
    def {{ sub.callback_name }}(self, msg):
        """
        Callback for subscriber on topic '{{ sub.topic }}'

        Args:
            msg: {{ sub.msg_class }} message
        """
        # Process messages in any state (or check state if needed)
{% if sub.code %}
{{ sub.code | indent(8, True) }}
{% else %}
        # TODO: Implement subscriber logic
        self.get_logger().info(f'Received message: {msg}')
{% endif %}

{% endfor %}
{% endif %}


def main(args=None):
    """Main entry point"""
    rclpy.init(args=args)

    node = {{ class_name }}()

    try:
        # Lifecycle nodes require an executor
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        # Proper shutdown
        node.get_logger().info('{{ node_name }} shutting down')
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
