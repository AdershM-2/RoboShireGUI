"""
Nav2 Configuration Generator - Generate Nav2 YAML configs and launch files

This module generates all necessary files for Nav2 navigation stack integration
including costmap configs, planner params, controller params, and launch files.

Author: RoboShire Team
Version: 2.0.0
"""

from pathlib import Path
from typing import Dict, Optional
import yaml
import logging


class Nav2ConfigGenerator:
    """Generate Nav2 configuration files from wizard settings"""

    def __init__(self):
        self.config = {}

    def generate_all(self, config: Dict, output_dir: Path) -> bool:
        """
        Generate all Nav2 configuration files

        Args:
            config: Configuration dictionary from Nav2IntegrationWizard
            output_dir: Directory to save configuration files

        Returns:
            bool: Success status
        """
        self.config = config
        output_dir = Path(output_dir)

        try:
            # Create directories
            config_dir = output_dir / "config"
            launch_dir = output_dir / "launch"
            config_dir.mkdir(parents=True, exist_ok=True)
            launch_dir.mkdir(parents=True, exist_ok=True)

            # Generate configuration files
            self._generate_costmap_config(config_dir / "costmap_common.yaml")
            self._generate_global_costmap_config(config_dir / "global_costmap.yaml")
            self._generate_local_costmap_config(config_dir / "local_costmap.yaml")
            self._generate_planner_config(config_dir / "planner.yaml")
            self._generate_controller_config(config_dir / "controller.yaml")
            self._generate_nav2_params(config_dir / "nav2_params.yaml")

            # Generate launch file
            self._generate_nav2_launch(launch_dir / "nav2_launch.py")

            logging.info(f"Nav2 configuration generated in {output_dir}")
            return True

        except Exception as e:
            logging.error(f"Failed to generate Nav2 configuration: {e}")
            return False

    def _generate_costmap_common(self) -> Dict:
        """Generate common costmap parameters"""
        robot = self.config['robot']
        costmap = self.config['costmap']

        footprint = f"[[{robot['robot_radius']}, 0.0], [0.0, {robot['robot_radius']}], [-{robot['robot_radius']}, 0.0], [0.0, -{robot['robot_radius']}]]"

        layers = []

        # Static layer (for map obstacles)
        layers.append("static_layer")

        # Obstacle layer (for sensor data)
        if robot['sensors']['lidar'] or robot['sensors']['camera']:
            layers.append("obstacle_layer")

        # Inflation layer (always needed)
        layers.append("inflation_layer")

        return {
            'robot_base_frame': 'base_link',
            'global_frame': 'map',
            'robot_radius': robot['robot_radius'],
            'footprint': footprint,
            'update_frequency': costmap['local']['update_frequency'],
            'publish_frequency': 2.0,
            'rolling_window': False,
            'plugins': layers,

            # Static layer
            'static_layer': {
                'plugin': 'nav2_costmap_2d::StaticLayer',
                'map_subscribe_transient_local': True
            },

            # Obstacle layer
            'obstacle_layer': {
                'plugin': 'nav2_costmap_2d::ObstacleLayer',
                'enabled': True,
                'observation_sources': 'scan' if robot['sensors']['lidar'] else '',
                'scan': {
                    'topic': '/scan',
                    'max_obstacle_height': 2.0,
                    'clearing': True,
                    'marking': True,
                    'data_type': 'LaserScan',
                    'raytrace_max_range': costmap['obstacle']['raytrace_range'],
                    'raytrace_min_range': 0.0,
                    'obstacle_max_range': costmap['obstacle']['obstacle_range'],
                    'obstacle_min_range': 0.0
                }
            },

            # Inflation layer
            'inflation_layer': {
                'plugin': 'nav2_costmap_2d::InflationLayer',
                'cost_scaling_factor': 3.0,
                'inflation_radius': robot['robot_radius'] * 2.0
            }
        }

    def _generate_costmap_config(self, output_path: Path):
        """Generate common costmap configuration"""
        config = self._generate_costmap_common()

        with open(output_path, 'w') as f:
            f.write("# Common costmap parameters\n")
            f.write("# Generated by RoboShire v2.0.0 Nav2 Integration Wizard\n\n")
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _generate_global_costmap_config(self, output_path: Path):
        """Generate global costmap configuration"""
        costmap = self.config['costmap']['global']

        config = {
            'global_costmap': {
                'global_frame': 'map',
                'robot_base_frame': 'base_link',
                'update_frequency': costmap['update_frequency'],
                'publish_frequency': 1.0,
                'width': int(costmap['width'] / costmap['resolution']),
                'height': int(costmap['height'] / costmap['resolution']),
                'resolution': costmap['resolution'],
                'rolling_window': False,
                'track_unknown_space': True
            }
        }

        with open(output_path, 'w') as f:
            f.write("# Global costmap parameters\n")
            f.write("# Generated by RoboShire v2.0.0\n\n")
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _generate_local_costmap_config(self, output_path: Path):
        """Generate local costmap configuration"""
        costmap = self.config['costmap']['local']

        config = {
            'local_costmap': {
                'global_frame': 'odom',
                'robot_base_frame': 'base_link',
                'update_frequency': costmap['update_frequency'],
                'publish_frequency': 2.0,
                'width': int(costmap['width'] / costmap['resolution']),
                'height': int(costmap['height'] / costmap['resolution']),
                'resolution': costmap['resolution'],
                'rolling_window': True,
                'always_send_full_costmap': True
            }
        }

        with open(output_path, 'w') as f:
            f.write("# Local costmap parameters\n")
            f.write("# Generated by RoboShire v2.0.0\n\n")
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _generate_planner_config(self, output_path: Path):
        """Generate planner configuration"""
        planner = self.config['planner']
        planner_type = planner['planner_type']

        config = {}

        if planner_type == 'NavFn':
            config['planner_server'] = {
                'ros__parameters': {
                    'expected_planner_frequency': 20.0,
                    'planner_plugins': ['GridBased'],
                    'GridBased': {
                        'plugin': 'nav2_navfn_planner/NavfnPlanner',
                        'tolerance': planner['tolerance'],
                        'use_astar': False,
                        'allow_unknown': True
                    }
                }
            }

        elif planner_type == 'SmacPlanner2D':
            config['planner_server'] = {
                'ros__parameters': {
                    'expected_planner_frequency': 20.0,
                    'planner_plugins': ['GridBased'],
                    'GridBased': {
                        'plugin': 'nav2_smac_planner/SmacPlanner2D',
                        'tolerance': planner['tolerance'],
                        'downsample_costmap': False,
                        'downsampling_factor': 1,
                        'allow_unknown': True,
                        'max_iterations': 1000000,
                        'max_on_approach_iterations': 1000,
                        'max_planning_time': 5.0,
                        'motion_model_for_search': '2D',
                        'angle_quantization_bins': 72,
                        'analytic_expansion_ratio': 3.5,
                        'analytic_expansion_max_length': 3.0,
                        'minimum_turning_radius': 0.40,
                        'reverse_penalty': 2.0,
                        'change_penalty': 0.0,
                        'non_straight_penalty': 1.2,
                        'cost_penalty': 2.0,
                        'retrospective_penalty': 0.015
                    }
                }
            }

        elif planner_type == 'ThetaStar':
            config['planner_server'] = {
                'ros__parameters': {
                    'expected_planner_frequency': 20.0,
                    'planner_plugins': ['GridBased'],
                    'GridBased': {
                        'plugin': 'nav2_theta_star_planner/ThetaStarPlanner',
                        'tolerance': planner['tolerance'],
                        'how_many_corners': 8,
                        'w_euc_cost': 1.0,
                        'w_traversal_cost': 2.0,
                        'w_heuristic_cost': 1.0
                    }
                }
            }

        with open(output_path, 'w') as f:
            f.write(f"# {planner_type} planner parameters\n")
            f.write("# Generated by RoboShire v2.0.0\n\n")
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _generate_controller_config(self, output_path: Path):
        """Generate controller configuration"""
        controller = self.config['controller']
        controller_type = controller['controller_type']
        robot = self.config['robot']

        config = {}

        if controller_type == 'DWB':
            config['controller_server'] = {
                'ros__parameters': {
                    'controller_frequency': 20.0,
                    'min_x_velocity_threshold': 0.001,
                    'min_y_velocity_threshold': 0.001 if robot['drive_type'] == 'omnidirectional' else 0.0,
                    'min_theta_velocity_threshold': 0.001,
                    'failure_tolerance': 0.3,
                    'progress_checker_plugin': 'progress_checker',
                    'goal_checker_plugins': ['general_goal_checker'],
                    'controller_plugins': ['FollowPath'],

                    'progress_checker': {
                        'plugin': 'nav2_controller::SimpleProgressChecker',
                        'required_movement_radius': 0.5,
                        'movement_time_allowance': 10.0
                    },

                    'general_goal_checker': {
                        'stateful': True,
                        'plugin': 'nav2_controller::SimpleGoalChecker',
                        'xy_goal_tolerance': controller['xy_goal_tolerance'],
                        'yaw_goal_tolerance': controller['yaw_goal_tolerance']
                    },

                    'FollowPath': {
                        'plugin': 'dwb_core::DWBLocalPlanner',
                        'debug_trajectory_details': True,
                        'min_vel_x': 0.0,
                        'min_vel_y': 0.0,
                        'max_vel_x': controller['max_vel_x'],
                        'max_vel_y': 0.0 if robot['drive_type'] == 'differential' else controller['max_vel_x'],
                        'max_vel_theta': controller['max_vel_theta'],
                        'min_speed_xy': 0.0,
                        'max_speed_xy': controller['max_vel_x'],
                        'min_speed_theta': 0.0,
                        'acc_lim_x': robot['acc_lim_x'],
                        'acc_lim_y': robot['acc_lim_x'] if robot['drive_type'] == 'omnidirectional' else 0.0,
                        'acc_lim_theta': robot['acc_lim_theta'],
                        'decel_lim_x': -robot['acc_lim_x'],
                        'decel_lim_y': -robot['acc_lim_x'] if robot['drive_type'] == 'omnidirectional' else 0.0,
                        'decel_lim_theta': -robot['acc_lim_theta'],
                        'vx_samples': 20,
                        'vy_samples': 5 if robot['drive_type'] == 'omnidirectional' else 0,
                        'vtheta_samples': 20,
                        'sim_time': 1.7,
                        'linear_granularity': 0.05,
                        'angular_granularity': 0.025,
                        'transform_tolerance': 0.2,
                        'xy_goal_tolerance': controller['xy_goal_tolerance'],
                        'trans_stopped_velocity': 0.25,
                        'short_circuit_trajectory_evaluation': True,
                        'stateful': True,
                        'critics': ['RotateToGoal', 'Oscillation', 'BaseObstacle', 'GoalAlign', 'PathAlign', 'PathDist', 'GoalDist'],
                        'BaseObstacle.scale': 0.02,
                        'PathAlign.scale': 32.0,
                        'PathAlign.forward_point_distance': 0.1,
                        'GoalAlign.scale': 24.0,
                        'GoalAlign.forward_point_distance': 0.1,
                        'PathDist.scale': 32.0,
                        'GoalDist.scale': 24.0,
                        'RotateToGoal.scale': 32.0,
                        'RotateToGoal.slowing_factor': 5.0,
                        'RotateToGoal.lookahead_time': -1.0
                    }
                }
            }

        elif controller_type == 'TEB':
            config['controller_server'] = {
                'ros__parameters': {
                    'controller_frequency': 20.0,
                    'min_x_velocity_threshold': 0.001,
                    'min_theta_velocity_threshold': 0.001,
                    'failure_tolerance': 0.3,
                    'progress_checker_plugin': 'progress_checker',
                    'goal_checker_plugins': ['general_goal_checker'],
                    'controller_plugins': ['FollowPath'],

                    'progress_checker': {
                        'plugin': 'nav2_controller::SimpleProgressChecker',
                        'required_movement_radius': 0.5,
                        'movement_time_allowance': 10.0
                    },

                    'general_goal_checker': {
                        'stateful': True,
                        'plugin': 'nav2_controller::SimpleGoalChecker',
                        'xy_goal_tolerance': controller['xy_goal_tolerance'],
                        'yaw_goal_tolerance': controller['yaw_goal_tolerance']
                    },

                    'FollowPath': {
                        'plugin': 'teb_local_planner::TebLocalPlannerROS',
                        'teb_autosize': True,
                        'dt_ref': 0.3,
                        'dt_hysteresis': 0.1,
                        'max_samples': 500,
                        'global_plan_overwrite_orientation': True,
                        'allow_init_with_backwards_motion': False,
                        'max_global_plan_lookahead_dist': 3.0,
                        'global_plan_viapoint_sep': -1.0,
                        'global_plan_prune_distance': 1.0,
                        'exact_arc_length': False,
                        'feasibility_check_no_poses': 2,
                        'publish_feedback': False,
                        'min_samples': 3,
                        'max_vel_x': controller['max_vel_x'],
                        'max_vel_theta': controller['max_vel_theta'],
                        'acc_lim_x': robot['acc_lim_x'],
                        'acc_lim_theta': robot['acc_lim_theta'],
                        'footprint_model': {
                            'type': 'circular',
                            'radius': robot['robot_radius']
                        }
                    }
                }
            }

        elif controller_type == 'RPP':
            config['controller_server'] = {
                'ros__parameters': {
                    'controller_frequency': 20.0,
                    'min_x_velocity_threshold': 0.001,
                    'min_theta_velocity_threshold': 0.001,
                    'failure_tolerance': 0.3,
                    'progress_checker_plugin': 'progress_checker',
                    'goal_checker_plugins': ['general_goal_checker'],
                    'controller_plugins': ['FollowPath'],

                    'progress_checker': {
                        'plugin': 'nav2_controller::SimpleProgressChecker',
                        'required_movement_radius': 0.5,
                        'movement_time_allowance': 10.0
                    },

                    'general_goal_checker': {
                        'stateful': True,
                        'plugin': 'nav2_controller::SimpleGoalChecker',
                        'xy_goal_tolerance': controller['xy_goal_tolerance'],
                        'yaw_goal_tolerance': controller['yaw_goal_tolerance']
                    },

                    'FollowPath': {
                        'plugin': 'nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController',
                        'desired_linear_vel': controller['max_vel_x'],
                        'lookahead_dist': 0.6,
                        'min_lookahead_dist': 0.3,
                        'max_lookahead_dist': 0.9,
                        'lookahead_time': 1.5,
                        'rotate_to_heading_angular_vel': controller['max_vel_theta'],
                        'transform_tolerance': 0.1,
                        'use_velocity_scaled_lookahead_dist': False,
                        'min_approach_linear_velocity': 0.05,
                        'approach_velocity_scaling_dist': 0.6,
                        'use_collision_detection': True,
                        'max_allowed_time_to_collision_up_to_carrot': 1.0,
                        'use_regulated_linear_velocity_scaling': True,
                        'use_cost_regulated_linear_velocity_scaling': False,
                        'regulated_linear_scaling_min_radius': 0.9,
                        'regulated_linear_scaling_min_speed': 0.25,
                        'use_rotate_to_heading': True,
                        'allow_reversing': False,
                        'rotate_to_heading_min_angle': 0.785,
                        'max_angular_accel': robot['acc_lim_theta'],
                        'max_robot_pose_search_dist': 10.0
                    }
                }
            }

        with open(output_path, 'w') as f:
            f.write(f"# {controller_type} controller parameters\n")
            f.write("# Generated by RoboShire v2.0.0\n\n")
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _generate_nav2_params(self, output_path: Path):
        """Generate consolidated Nav2 parameters file"""
        robot = self.config['robot']

        # All Nav2 server parameters
        config = {
            'bt_navigator': {
                'ros__parameters': {
                    'use_sim_time': False,
                    'global_frame': 'map',
                    'robot_base_frame': 'base_link',
                    'odom_topic': '/odom',
                    'bt_loop_duration': 10,
                    'default_server_timeout': 20,
                    'enable_groot_monitoring': True,
                    'groot_zmq_publisher_port': 1666,
                    'groot_zmq_server_port': 1667,
                    'plugin_lib_names': [
                        'nav2_compute_path_to_pose_action_bt_node',
                        'nav2_compute_path_through_poses_action_bt_node',
                        'nav2_smooth_path_action_bt_node',
                        'nav2_follow_path_action_bt_node',
                        'nav2_spin_action_bt_node',
                        'nav2_wait_action_bt_node',
                        'nav2_back_up_action_bt_node',
                        'nav2_drive_on_heading_bt_node',
                        'nav2_clear_costmap_service_bt_node',
                        'nav2_is_stuck_condition_bt_node',
                        'nav2_goal_reached_condition_bt_node',
                        'nav2_goal_updated_condition_bt_node',
                        'nav2_globally_updated_goal_condition_bt_node',
                        'nav2_is_path_valid_condition_bt_node',
                        'nav2_initial_pose_received_condition_bt_node',
                        'nav2_reinitialize_global_localization_service_bt_node',
                        'nav2_rate_controller_bt_node',
                        'nav2_distance_controller_bt_node',
                        'nav2_speed_controller_bt_node',
                        'nav2_truncate_path_action_bt_node',
                        'nav2_truncate_path_local_action_bt_node',
                        'nav2_goal_updater_node_bt_node',
                        'nav2_recovery_node_bt_node',
                        'nav2_pipeline_sequence_bt_node',
                        'nav2_round_robin_node_bt_node',
                        'nav2_transform_available_condition_bt_node',
                        'nav2_time_expired_condition_bt_node',
                        'nav2_path_expiring_timer_condition',
                        'nav2_distance_traveled_condition_bt_node',
                        'nav2_single_trigger_bt_node',
                        'nav2_is_battery_low_condition_bt_node',
                        'nav2_navigate_through_poses_action_bt_node',
                        'nav2_navigate_to_pose_action_bt_node',
                        'nav2_remove_passed_goals_action_bt_node',
                        'nav2_planner_selector_bt_node',
                        'nav2_controller_selector_bt_node',
                        'nav2_goal_checker_selector_bt_node'
                    ]
                }
            },

            'bt_navigator_navigate_through_poses_rclcpp_node': {
                'ros__parameters': {
                    'use_sim_time': False
                }
            },

            'bt_navigator_navigate_to_pose_rclcpp_node': {
                'ros__parameters': {
                    'use_sim_time': False
                }
            },

            'recoveries_server': {
                'ros__parameters': {
                    'costmap_topic': 'local_costmap/costmap_raw',
                    'footprint_topic': 'local_costmap/published_footprint',
                    'cycle_frequency': 10.0,
                    'recovery_plugins': ['spin', 'backup', 'wait'],
                    'spin': {
                        'plugin': 'nav2_recoveries/Spin'
                    },
                    'backup': {
                        'plugin': 'nav2_recoveries/BackUp'
                    },
                    'wait': {
                        'plugin': 'nav2_recoveries/Wait'
                    },
                    'global_frame': 'odom',
                    'robot_base_frame': 'base_link',
                    'transform_timeout': 0.1,
                    'use_sim_time': False,
                    'simulate_ahead_time': 2.0,
                    'max_rotational_vel': robot['max_vel_theta'],
                    'min_rotational_vel': 0.4,
                    'rotational_acc_lim': robot['acc_lim_theta']
                }
            }
        }

        with open(output_path, 'w') as f:
            f.write("# Nav2 Parameters\n")
            f.write("# Generated by RoboShire v2.0.0\n\n")
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

    def _generate_nav2_launch(self, output_path: Path):
        """Generate Nav2 launch file"""
        robot_name = self.config['robot']['robot_name']

        launch_content = f'''"""
Nav2 Launch File
Generated by RoboShire v2.0.0 Nav2 Integration Wizard

This launch file starts the complete Nav2 navigation stack including:
- Map Server
- AMCL Localization
- Planner Server
- Controller Server
- Recoveries Server
- Behavior Tree Navigator
- Lifecycle Manager
"""

import os
from pathlib import Path
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, SetEnvironmentVariable
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from nav2_common.launch import RewrittenYaml


def generate_launch_description():
    # Get package directories
    pkg_dir = get_package_share_directory('{robot_name}')
    nav2_bringup_dir = get_package_share_directory('nav2_bringup')

    # Paths to configuration files
    nav2_params_file = os.path.join(pkg_dir, 'config', 'nav2_params.yaml')
    costmap_common_file = os.path.join(pkg_dir, 'config', 'costmap_common.yaml')
    global_costmap_file = os.path.join(pkg_dir, 'config', 'global_costmap.yaml')
    local_costmap_file = os.path.join(pkg_dir, 'config', 'local_costmap.yaml')
    planner_file = os.path.join(pkg_dir, 'config', 'planner.yaml')
    controller_file = os.path.join(pkg_dir, 'config', 'controller.yaml')

    # Map file (you need to provide this)
    map_file = os.path.join(pkg_dir, 'maps', 'my_map.yaml')

    # Launch arguments
    use_sim_time = LaunchConfiguration('use_sim_time')
    autostart = LaunchConfiguration('autostart')
    params_file = LaunchConfiguration('params_file')

    declare_use_sim_time_cmd = DeclareLaunchArgument(
        'use_sim_time',
        default_value='False',
        description='Use simulation (Gazebo) clock if true')

    declare_autostart_cmd = DeclareLaunchArgument(
        'autostart',
        default_value='True',
        description='Automatically startup the nav2 stack')

    declare_params_file_cmd = DeclareLaunchArgument(
        'params_file',
        default_value=nav2_params_file,
        description='Full path to the ROS2 parameters file to use')

    # Include Nav2 bringup launch
    nav2_bringup_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(nav2_bringup_dir, 'launch', 'bringup_launch.py')),
        launch_arguments={{
            'map': map_file,
            'use_sim_time': use_sim_time,
            'params_file': params_file,
            'autostart': autostart
        }}.items()
    )

    # Create launch description
    ld = LaunchDescription()

    # Add launch arguments
    ld.add_action(declare_use_sim_time_cmd)
    ld.add_action(declare_autostart_cmd)
    ld.add_action(declare_params_file_cmd)

    # Add Nav2 bringup
    ld.add_action(nav2_bringup_launch)

    return ld
'''

        with open(output_path, 'w') as f:
            f.write(launch_content)


# Standalone test
if __name__ == "__main__":
    # Test configuration
    test_config = {
        'robot': {
            'robot_name': 'test_robot',
            'robot_radius': 0.3,
            'max_vel_x': 0.5,
            'max_vel_theta': 1.0,
            'acc_lim_x': 0.5,
            'acc_lim_theta': 1.0,
            'drive_type': 'differential',
            'sensors': {'lidar': True, 'camera': False, 'sonar': False}
        },
        'costmap': {
            'global': {'width': 50.0, 'height': 50.0, 'resolution': 0.05, 'update_frequency': 1.0},
            'local': {'width': 5.0, 'height': 5.0, 'resolution': 0.05, 'update_frequency': 5.0},
            'obstacle': {'obstacle_range': 6.0, 'raytrace_range': 8.0}
        },
        'planner': {'planner_type': 'NavFn', 'tolerance': 0.1, 'use_final_approach_orientation': True},
        'controller': {'controller_type': 'DWB', 'max_vel_x': 0.5, 'max_vel_theta': 1.0,
                      'xy_goal_tolerance': 0.1, 'yaw_goal_tolerance': 0.1}
    }

    generator = Nav2ConfigGenerator()
    output_dir = Path("./test_nav2_output")
    success = generator.generate_all(test_config, output_dir)

    if success:
        print(f"✅ Nav2 configuration generated successfully in {output_dir}")
    else:
        print("❌ Failed to generate Nav2 configuration")
