"""
Code Generator

Generates ROS2 Python packages from NodeGraph using Jinja2 templates.
"""

from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime
from jinja2 import Environment, FileSystemLoader, Template
import logging

from roboshire.backend.node_graph import NodeGraph, Node, NodeType


class CodeGenerator:
    """Generates ROS2 code from NodeGraph"""

    def __init__(self, template_dir: Optional[Path] = None):
        """
        Initialize CodeGenerator

        Args:
            template_dir: Directory containing Jinja2 templates.
                         If None, uses default robotstudio/templates/
        """
        if template_dir is None:
            # Default to robotstudio/templates/
            module_dir = Path(__file__).parent.parent
            template_dir = module_dir / "templates"

        self.template_dir = Path(template_dir)

        # Initialize Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.template_dir)),
            trim_blocks=True,
            lstrip_blocks=True
        )

        self.logger = logging.getLogger(__name__)

    def generate_package(
        self,
        graph: NodeGraph,
        package_name: str,
        output_dir: Path,
        maintainer_name: str = "User",
        maintainer_email: str = "user@example.com",
        license_type: str = "Apache-2.0",
        description: str = "ROS2 package generated by RoboShire"
    ) -> bool:
        """
        Generate complete ROS2 package from NodeGraph

        Args:
            graph: NodeGraph to generate code from
            package_name: Name of the ROS2 package
            output_dir: Directory to create package in (usually workspace/src/)
            maintainer_name: Package maintainer name
            maintainer_email: Package maintainer email
            license_type: Package license
            description: Package description

        Returns:
            True if generation succeeded, False otherwise
        """
        try:
            # Validate graph first
            is_valid, errors = graph.validate()
            if not is_valid:
                self.logger.error(f"Cannot generate code - graph has errors:")
                for error in errors:
                    self.logger.error(f"  - {error}")
                return False

            # Create package directory structure
            pkg_dir = Path(output_dir) / package_name
            self._create_package_structure(pkg_dir, package_name)

            # Collect dependencies from all nodes
            dependencies = self._collect_dependencies(graph)

            # Generate package.xml
            self._generate_package_xml(
                pkg_dir,
                package_name,
                description,
                maintainer_name,
                maintainer_email,
                license_type,
                dependencies
            )

            # Generate Python nodes
            node_entries = []
            for node in graph.nodes.values():
                if self._should_generate_node(node):
                    node_file = self._generate_node_file(pkg_dir, package_name, node)
                    if node_file:
                        # Add to entry points
                        node_entries.append({
                            'executable_name': node.name,
                            'module_name': node_file.stem
                        })

            # Generate setup.py
            self._generate_setup_py(
                pkg_dir,
                package_name,
                description,
                maintainer_name,
                maintainer_email,
                license_type,
                node_entries
            )

            # Generate setup.cfg
            self._generate_setup_cfg(pkg_dir, package_name)

            # Generate __init__.py for Python package
            (pkg_dir / package_name / "__init__.py").write_text("")

            # Create resource marker file
            (pkg_dir / "resource" / package_name).write_text("")

            # Generate launch file
            self._generate_launch_file(pkg_dir, package_name, node_entries, graph)

            self.logger.info(f"Successfully generated package '{package_name}' at {pkg_dir}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to generate package: {e}")
            import traceback
            traceback.print_exc()
            return False

    def _create_package_structure(self, pkg_dir: Path, package_name: str):
        """Create the standard ROS2 Python package directory structure"""
        # Create directories
        (pkg_dir / package_name).mkdir(parents=True, exist_ok=True)
        (pkg_dir / "launch").mkdir(exist_ok=True)
        (pkg_dir / "urdf").mkdir(exist_ok=True)
        (pkg_dir / "resource").mkdir(exist_ok=True)

    def _collect_dependencies(self, graph: NodeGraph) -> List[str]:
        """Collect all ROS2 package dependencies from the graph"""
        dependencies = set()

        for node in graph.nodes.values():
            # Extract package from message type (e.g., "std_msgs/String" -> "std_msgs")
            for port in node.ports.values():
                if port.data_type and '/' in port.data_type:
                    pkg = port.data_type.split('/')[0]
                    dependencies.add(pkg)

            # Add service dependencies
            if node.node_type in [NodeType.SERVICE_SERVER, NodeType.SERVICE_CLIENT]:
                srv_type = node.properties.get('service_type', '')
                if srv_type and '/' in srv_type:
                    pkg = srv_type.split('/')[0]
                    dependencies.add(pkg)

        return sorted(dependencies)

    def _should_generate_node(self, node: Node) -> bool:
        """Check if we should generate code for this node"""
        # Generate code for these node types
        generate_types = [
            NodeType.PUBLISHER,
            NodeType.SUBSCRIBER,
            NodeType.TIMER,
            NodeType.LIFECYCLE,  # Phase 6: Lifecycle nodes
        ]
        return node.node_type in generate_types

    def _generate_node_file(
        self,
        pkg_dir: Path,
        package_name: str,
        node: Node
    ) -> Optional[Path]:
        """Generate Python file for a single node"""
        try:
            # Prepare template data
            template_data = self._prepare_node_template_data(node)

            # Select template based on node type
            if node.node_type == NodeType.LIFECYCLE:
                template = self.jinja_env.get_template('lifecycle_node.py.j2')
            else:
                template = self.jinja_env.get_template('python_node.py.j2')

            # Render template
            code = template.render(**template_data)

            # Write to file
            node_file = pkg_dir / package_name / f"{node.name}.py"
            node_file.write_text(code)

            self.logger.info(f"Generated node file: {node_file}")
            return node_file

        except Exception as e:
            self.logger.error(f"Failed to generate node {node.name}: {e}")
            return None

    def _prepare_node_template_data(self, node: Node) -> dict:
        """Prepare data dictionary for node template"""
        # Convert node name to valid Python class name
        class_name = ''.join(word.capitalize() for word in node.name.split('_'))
        if not class_name.endswith('Node'):
            class_name += 'Node'

        data = {
            'node_name': node.name,
            'class_name': class_name,
            'description': f"ROS2 {node.node_type.value} node",
            'generation_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'message_imports': [],
            'publishers': [],
            'subscribers': [],
            'timers': [],
            'service_servers': [],
            'service_clients': [],
            'parameters': []
        }

        # Process based on node type
        if node.node_type == NodeType.PUBLISHER:
            self._add_publisher_data(data, node)

        elif node.node_type == NodeType.SUBSCRIBER:
            self._add_subscriber_data(data, node)

        elif node.node_type == NodeType.TIMER:
            self._add_timer_data(data, node)

        elif node.node_type == NodeType.LIFECYCLE:
            self._add_lifecycle_data(data, node)

        return data

    def _add_publisher_data(self, data: dict, node: Node):
        """Add publisher-specific template data"""
        topic = node.properties.get('topic', '/topic')
        msg_type = node.properties.get('msg_type', 'std_msgs/String')
        rate = node.properties.get('rate', 1.0)
        queue_size = node.properties.get('queue_size', 10)

        # Add import
        pkg, msg_class = msg_type.split('/')
        data['message_imports'].append(f"from {pkg}.msg import {msg_class}")

        # Add publisher
        data['publishers'].append({
            'var_name': 'publisher',
            'topic': topic,
            'msg_class': msg_class,
            'queue_size': queue_size
        })

        # Add timer for periodic publishing
        data['timers'].append({
            'var_name': 'timer',
            'period': 1.0 / rate,
            'callback_name': 'timer_callback',
            'code': self._generate_publisher_callback(msg_class, topic)
        })

    def _generate_publisher_callback(self, msg_class: str, topic: str) -> str:
        """Generate code for publisher timer callback"""
        return f"""# Create and publish message
msg = {msg_class}()
# TODO: Set message fields
# msg.data = 'Hello ROS2!'
self.publisher.publish(msg)
self.get_logger().info(f'Publishing to {topic}')"""

    def _add_subscriber_data(self, data: dict, node: Node):
        """Add subscriber-specific template data"""
        topic = node.properties.get('topic', '/topic')
        msg_type = node.properties.get('msg_type', 'std_msgs/String')
        queue_size = node.properties.get('queue_size', 10)

        # Add import
        pkg, msg_class = msg_type.split('/')
        data['message_imports'].append(f"from {pkg}.msg import {msg_class}")

        # Add subscriber
        data['subscribers'].append({
            'var_name': 'subscriber',
            'topic': topic,
            'msg_class': msg_class,
            'queue_size': queue_size,
            'callback_name': 'subscriber_callback',
            'code': f"self.get_logger().info(f'Received: {{msg}}')"
        })

    def _add_timer_data(self, data: dict, node: Node):
        """Add timer-specific template data"""
        period = node.properties.get('period', 1.0)

        data['timers'].append({
            'var_name': 'timer',
            'period': period,
            'callback_name': 'timer_callback',
            'code': f"self.get_logger().info('Timer callback - period {period}s')"
        })

    def _generate_package_xml(
        self,
        pkg_dir: Path,
        package_name: str,
        description: str,
        maintainer_name: str,
        maintainer_email: str,
        license_type: str,
        dependencies: List[str]
    ):
        """Generate package.xml"""
        template = self.jinja_env.get_template('package_xml.j2')
        content = template.render(
            package_name=package_name,
            version='0.1.0',
            description=description,
            maintainer_name=maintainer_name,
            maintainer_email=maintainer_email,
            license=license_type,
            dependencies=dependencies
        )

        (pkg_dir / "package.xml").write_text(content)
        self.logger.info("Generated package.xml")

    def _generate_setup_py(
        self,
        pkg_dir: Path,
        package_name: str,
        description: str,
        maintainer_name: str,
        maintainer_email: str,
        license_type: str,
        node_entries: List[dict]
    ):
        """Generate setup.py"""
        template = self.jinja_env.get_template('setup_py.j2')
        content = template.render(
            package_name=package_name,
            version='0.1.0',
            description=description,
            maintainer_name=maintainer_name,
            maintainer_email=maintainer_email,
            license=license_type,
            nodes=node_entries
        )

        (pkg_dir / "setup.py").write_text(content)
        self.logger.info("Generated setup.py")

    def _generate_setup_cfg(self, pkg_dir: Path, package_name: str):
        """Generate setup.cfg"""
        template = self.jinja_env.get_template('setup_cfg.j2')
        content = template.render(package_name=package_name)

        (pkg_dir / "setup.cfg").write_text(content)
        self.logger.info("Generated setup.cfg")

    def _generate_launch_file(
        self,
        pkg_dir: Path,
        package_name: str,
        node_entries: List[dict],
        graph: NodeGraph
    ):
        """Generate launch file"""
        # Prepare node data for launch file
        launch_nodes = []
        for entry in node_entries:
            node_name = entry['executable_name']
            node = graph.get_node(self._find_node_id_by_name(graph, node_name))

            launch_nodes.append({
                'executable_name': entry['executable_name'],
                'name': node_name,
                'description': f"{node.node_type.value} node",
                'parameters': '{}',  # TODO: Add parameter support
                'remappings': ''
            })

        template = self.jinja_env.get_template('launch_file.py.j2')
        content = template.render(
            package_name=package_name,
            generation_date=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            nodes=launch_nodes
        )

        launch_file = pkg_dir / "launch" / f"{package_name}_launch.py"
        launch_file.write_text(content)
        self.logger.info(f"Generated launch file: {launch_file}")

    def _find_node_id_by_name(self, graph: NodeGraph, name: str) -> Optional[str]:
        """Find node ID by name"""
        for node_id, node in graph.nodes.items():
            if node.name == name:
                return node_id
        return None

    def _add_lifecycle_data(self, data: dict, node: Node):
        """Add lifecycle node-specific template data (Phase 6)"""
        lifecycle_type = node.properties.get('lifecycle_type', 'publisher')

        data['description'] = f"ROS2 Lifecycle {lifecycle_type.capitalize()} node"

        if lifecycle_type == 'publisher':
            topic = node.properties.get('topic', '/topic')
            msg_type = node.properties.get('msg_type', 'std_msgs/String')
            rate = node.properties.get('rate', 1.0)
            queue_size = node.properties.get('queue_size', 10)

            # Add import
            pkg, msg_class = msg_type.split('/')
            data['message_imports'].append(f"from {pkg}.msg import {msg_class}")

            # Add publisher
            data['publishers'].append({
                'var_name': 'publisher',
                'topic': topic,
                'msg_class': msg_class,
                'queue_size': queue_size
            })

            # Add timer for periodic publishing
            data['timers'].append({
                'var_name': 'timer',
                'period': 1.0 / rate,
                'callback_name': 'timer_callback',
                'code': self._generate_lifecycle_publisher_callback(msg_class, topic)
            })

        elif lifecycle_type == 'subscriber':
            topic = node.properties.get('topic', '/topic')
            msg_type = node.properties.get('msg_type', 'std_msgs/String')
            queue_size = node.properties.get('queue_size', 10)

            # Add import
            pkg, msg_class = msg_type.split('/')
            data['message_imports'].append(f"from {pkg}.msg import {msg_class}")

            # Add subscriber
            data['subscribers'].append({
                'var_name': 'subscriber',
                'topic': topic,
                'msg_class': msg_class,
                'queue_size': queue_size,
                'callback_name': 'subscriber_callback',
                'code': f"self.get_logger().info(f'Received: {{msg}}')"
            })

    def _generate_lifecycle_publisher_callback(self, msg_class: str, topic: str) -> str:
        """Generate code for lifecycle publisher timer callback"""
        return f"""# Create and publish message (only when ACTIVE)
msg = {msg_class}()
# TODO: Set message fields
# msg.data = 'Hello from lifecycle node!'
self.publisher.publish(msg)
self.get_logger().info(f'Publishing to {topic} (ACTIVE state)')"""
